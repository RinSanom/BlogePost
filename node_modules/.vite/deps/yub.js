import {
  require_crypto
} from "./chunk-J2DLUBRI.js";
import {
  __commonJS
} from "./chunk-7D4SUZUM.js";

// node_modules/yub/lib/modhex.js
var require_modhex = __commonJS({
  "node_modules/yub/lib/modhex.js"(exports, module) {
    "use strict";
    var trans = "cbdefghijklnrtuv";
    function toHex(n) {
      return ("0" + n.toString(16)).substr(-2);
    }
    function decode(src) {
      var b = 0;
      var flag = false;
      var dst = null;
      var hex = "";
      var p1 = null;
      for (var i = 0; i < src.length; i++) {
        p1 = trans.indexOf(src[i]);
        if (p1 == -1) {
          return null;
        }
        b = p1 == -1 ? 0 : p1;
        if (flag = !flag) {
          dst = b;
        } else {
          hex += toHex(dst << 4 | b);
        }
      }
      return hex;
    }
    function decodeInt(src) {
      var d = decode(src);
      return d == null ? null : parseInt(d, 16);
    }
    module.exports = {
      decode,
      decodeInt
    };
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/yub/lib/yub.js
var require_yub = __commonJS({
  "node_modules/yub/lib/yub.js"(exports, module) {
    "use strict";
    var crypto = require_crypto();
    var modhex = require_modhex();
    var https = require_https();
    var qs = require_querystring();
    var servers = ["api.yubico.com", "api2.yubico.com", "api3.yubico.com", "api4.yubico.com", "api5.yubico.com"];
    var currentServerIdx = Math.floor(Math.random() * servers.length);
    var DEFAULT_NONCE_LENGTH = 40;
    var DEFAULT_MAX_TRIES = 3;
    function Yub(clientID, secretKey, options) {
      if (!clientID || !secretKey) throw new Error("Provide a client ID & secret key to yub.init()!");
      if (!options) options = {};
      this.clientID = clientID;
      this.secretKey = secretKey;
      this.maxTries = options.maxTries || DEFAULT_MAX_TRIES;
      this.nonceLength = options.nonceLength || DEFAULT_NONCE_LENGTH;
    }
    function parse(data) {
      var obj = data.split("\r\n"), retval = {}, kv = [];
      Object.keys(obj).map(function(key) {
        kv = obj[key].split("=", 2);
        if (kv[0].length > 0) {
          retval[kv[0]] = kv[1];
        }
      });
      return retval;
    }
    function calculateIdentity(otp) {
      var len = otp.length;
      return len > 32 ? otp.substring(0, len - 32) : null;
    }
    function calculateEncrypted(otp) {
      var len = otp.length;
      return len > 32 ? otp.substring(len - 32, len) : null;
    }
    function calculateStringToHash(obj) {
      return Object.keys(obj).sort().map(function(key) {
        return key + "=" + obj[key];
      }).join("&");
    }
    function calculateHmac(obj, secretKey) {
      var str = calculateStringToHash(obj);
      var buf = new Buffer(secretKey, "base64");
      var hmac = crypto.createHmac("sha1", buf);
      return hmac.update(str).digest("base64");
    }
    Yub.prototype.verifyWithYubico = function(params, callback, currentTry) {
      if (!currentTry) currentTry = 1;
      currentServerIdx = (currentServerIdx + 1) % servers.length;
      var server = servers[currentServerIdx];
      var uri = "https://" + server + "/wsapi/2.0/verify";
      var fullURI = uri + "?" + qs.stringify(params);
      var me = this;
      https.get(fullURI, function(res) {
        var shouldRetry = currentTry < me.maxTries;
        var badStatus = res && res.statusCode !== 200;
        var serverError = res && res.statusCode >= 500;
        if (shouldRetry && serverError) {
          return me.verifyWithYubico(params, callback, currentTry + 1);
        } else if (badStatus) {
          return callback(new Error("Bad status code: " + res.statusCode));
        }
        var buffer = "";
        res.on("data", function(chunk) {
          buffer += chunk;
        });
        res.on("end", function() {
          var body = parse(buffer);
          var bodyh = body.h;
          delete body.h;
          var h = calculateHmac(body, me.secretKey);
          body.signatureVerified = bodyh === h.replace("=", "");
          body.nonceVerified = params.nonce === body.nonce;
          body.identity = null;
          body.encrypted = null;
          body.encryptedHex = null;
          body.serial = null;
          if (body.status === "OK") {
            body.identity = calculateIdentity(params.otp);
            body.encrypted = calculateEncrypted(params.otp);
            body.encryptedHex = modhex.decode(body.encrypted);
            body.serial = modhex.decodeInt(body.identity);
            body.valid = body.signatureVerified && body.nonceVerified;
          } else {
            body.valid = false;
          }
          callback(null, body);
        });
      }).on("error", callback);
    };
    Yub.prototype.calculateParams = function(otp, callback) {
      var me = this;
      crypto.randomBytes(me.nonceLength / 2, function(err, buf) {
        if (err) return callback(err);
        var nonce = buf.toString("hex");
        var params = {
          id: me.clientID,
          nonce,
          otp
        };
        params.h = calculateHmac(params, me.secretKey);
        callback(null, params);
      });
    };
    Yub.prototype.verify = function(otp, callback) {
      var me = this;
      this.calculateParams(otp, function(err, params) {
        if (err) return callback(err);
        me.verifyWithYubico(params, callback);
      });
    };
    Yub.prototype.verifyOffline = function(otp, callback) {
      var identity = calculateIdentity(otp);
      var encrypted = calculateEncrypted(otp);
      var body = {
        t: null,
        otp,
        nonce: null,
        sl: "0",
        status: null,
        signatureVerified: false,
        nonceVerified: false,
        identity,
        encrypted,
        encryptedHex: modhex.decode(encrypted),
        serial: modhex.decodeInt(identity),
        valid: false
      };
      callback(null, body);
    };
    module.exports = Yub;
    var legacyInstance = null;
    Yub.init = function(clientID, secretKey) {
      legacyInstance = new Yub(clientID, secretKey, { maxTries: 0 });
    };
    Yub.verify = function(otp, callback) {
      if (!legacyInstance) throw new Error("init() before verifying!");
      return legacyInstance.verify(otp, callback);
    };
    Yub.verifyOffline = Yub.prototype.verifyOffline;
    Yub._calculateHmac = calculateHmac;
    Yub._calculateStringToHash = calculateStringToHash;
    Yub._servers = servers;
  }
});

// node_modules/yub/index.js
var require_yub2 = __commonJS({
  "node_modules/yub/index.js"(exports, module) {
    module.exports = require_yub();
  }
});
export default require_yub2();
//# sourceMappingURL=yub.js.map
