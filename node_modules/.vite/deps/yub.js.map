{
  "version": 3,
  "sources": ["../../yub/lib/modhex.js", "browser-external:https", "browser-external:querystring", "../../yub/lib/yub.js", "../../yub/index.js"],
  "sourcesContent": ["'use strict';\n// lookup table for modhex codes\nvar trans = 'cbdefghijklnrtuv';\n\n// convert number to 2 digit hex = 255 --> ff\nfunction toHex (n) {\n  return ('0' + n.toString(16)).substr(-2);\n}\n\n// decode a modhex string to a hexadecimal string\n// see http://static.yubico.com/var/uploads/pdfs/YubiKey_manual-2.2.pdf\nfunction decode (src) {\n  var b = 0;\n  var flag = false;\n  var dst = null;\n  var hex = '';\n  var p1 = null;\n\n  // convert string to hexadecimal string\n  for (var i=0; i < src.length; i++) {\n    p1 = trans.indexOf(src[i]);\n    if (p1 == -1) {\n      // if a unsupported digit is detected, return null\n      return null;\n    }\n    b = (p1 == -1) ? 0 : p1;\n    if ((flag = !flag)) {\n      dst = b;\n    } else {\n      hex += toHex(dst << 4 | b);\n    }\n  }\n\n  // return as hexadecimal number\n  return hex;\n}\n\n// decode a modhex string to an integer\n// see http://static.yubico.com/var/uploads/pdfs/YubiKey_manual-2.2.pdf\nfunction decodeInt (src) {\n  var d = decode(src);\n  return (d == null) ? null : parseInt(d, 16);\n};\n\nmodule.exports = {\n  decode: decode,\n  decodeInt: decodeInt\n};\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"https\" has been externalized for browser compatibility. Cannot access \"https.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"querystring\" has been externalized for browser compatibility. Cannot access \"querystring.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "'use strict';\nvar crypto = require('crypto');\nvar modhex = require('./modhex.js');\nvar https = require('https');\nvar qs = require('querystring');\n\n// List of valid servers. We go through them in round-robin fashion.\nvar servers = ['api.yubico.com', 'api2.yubico.com', 'api3.yubico.com', 'api4.yubico.com', 'api5.yubico.com'];\nvar currentServerIdx = Math.floor(Math.random() * servers.length);\n\n// Length of random nonce generated per-request\nvar DEFAULT_NONCE_LENGTH = 40;\n// For automatic retry\nvar DEFAULT_MAX_TRIES = 3;\n\nfunction Yub(clientID, secretKey, options) {\n  // store the client credentials\n  // Apply here https://upgrade.yubico.com/getapikey/\n  if (!clientID || !secretKey) throw new Error('Provide a client ID & secret key to yub.init()!');\n  if (!options) options = {};\n  this.clientID = clientID;\n  this.secretKey = secretKey;\n  this.maxTries = options.maxTries || DEFAULT_MAX_TRIES;\n  this.nonceLength = options.nonceLength || DEFAULT_NONCE_LENGTH;\n}\n\n// parse the returned date which is CR/LF delimited string with key/value pairs\n// separated by '='\nfunction parse (data) {\n  var obj = data.split('\\r\\n'),\n    retval = {},\n    kv = [];\n  Object.keys(obj).map(function(key) {\n    kv = obj[key].split('=', 2);\n    if (kv[0].length > 0) {\n      retval[kv[0]] = kv[1];\n    }\n  });\n  return retval;\n};\n\n// extract the identity portion of the Yubikey OTP i.e.\n//  the string with last 32 characters removed\nfunction calculateIdentity (otp) {\n  var len = otp.length;\n  return (len > 32) ? otp.substring(0, len - 32) : null;\n};\n\n// extract the encrypted portion of the Yubikey OTP i.e.\n//  the last 32 characters\nfunction calculateEncrypted (otp) {\n  var len = otp.length;\n  return (len > 32) ? otp.substring(len - 32, len) : null;\n};\n\n// calculate the string that is required to be hashed i.e.\n//  keys in alphabetical order, separated from values by '='\n//  and by each other by '&' (like querystrings, but without the escaping)\nfunction calculateStringToHash (obj) {\n  return Object\n    .keys(obj)\n    .sort()\n    .map(function(key) {\n      return key + '=' + obj[key];\n    })\n    .join('&');\n};\n\n// calculate the Hmac signature of an object\n// according to instructions here: https://code.google.com/p/yubikey-val-server-php/wiki/ValidationProtocolV20\nfunction calculateHmac (obj, secretKey) {\n  var str = calculateStringToHash(obj);\n  var buf = new Buffer(secretKey, 'base64');\n  var hmac = crypto.createHmac('sha1', buf);\n  return hmac.update(str).digest('base64');\n};\n\n// Verify with a random Yubico server.\nYub.prototype.verifyWithYubico = function (params, callback, currentTry) {\n  // Automatic retry logic\n  if (!currentTry) currentTry = 1;\n\n  // Choose a server in round-robin fashion. First offset is random.\n  currentServerIdx = (currentServerIdx + 1) % servers.length;\n  var server = servers[currentServerIdx];\n  var uri = 'https://' + server + '/wsapi/2.0/verify';\n  var fullURI = uri + '?' + qs.stringify(params);\n  var me = this;\n\n  // Send to Yubico.\n  https.get(fullURI, function(res) {\n    // Error handling\n    var shouldRetry = (currentTry < me.maxTries);\n    var badStatus = (res && res.statusCode !== 200);\n    var serverError = (res && res.statusCode >= 500);\n    if (shouldRetry && serverError) {\n      // Errored, but retry\n      return me.verifyWithYubico(params, callback, currentTry + 1);\n    } else if (badStatus) {\n      return callback(new Error('Bad status code: ' + res.statusCode));\n    }\n\n    // Parse body & go\n    var buffer = '';\n    res.on('data', function(chunk) {\n      buffer += chunk;\n    });\n    res.on('end', function() {\n      var body = parse(buffer);\n\n      // check whether the signature of the reply checks out\n      var bodyh = body.h;\n      delete body.h;\n      var h = calculateHmac(body, me.secretKey);\n      body.signatureVerified = (bodyh === h.replace('=', ''));\n\n      // check whether the nonce is the same as the one we gave it\n      body.nonceVerified = (params.nonce === body.nonce);\n\n      // calculate the key's identity\n      body.identity = null;\n      body.encrypted = null;\n      body.encryptedHex = null;\n      body.serial = null;\n      if (body.status === 'OK') {\n        body.identity = calculateIdentity(params.otp);\n        body.encrypted = calculateEncrypted(params.otp);\n        body.encryptedHex = modhex.decode(body.encrypted);\n        body.serial = modhex.decodeInt(body.identity);\n        body.valid = (body.signatureVerified && body.nonceVerified);\n      } else {\n        body.valid = false;\n      }\n\n      callback(null, body);\n    });\n  })\n  .on('error', callback);\n};\n\n// Calculate the params to be sent to Yubico.\nYub.prototype.calculateParams = function (otp, callback) {\n  var me = this;\n  // create a nonceLength-character random string\n  crypto.randomBytes(me.nonceLength / 2, function (err, buf) {\n    if (err) return callback(err);\n\n    // turn it to hex\n    var nonce = buf.toString('hex');\n\n    // create parameters to send to web service\n    var params = {\n      id: me.clientID,\n      nonce: nonce,\n      otp: otp\n    };\n\n    // calculate sha1 signature\n    params.h = calculateHmac(params, me.secretKey);\n\n    callback(null, params);\n  });\n};\n\n// Verify that the supplied one-time-password is valid or not\n// calls back with (err,data). If err is not null, then you have\n// an object in data to work with.\nYub.prototype.verify = function (otp, callback) {\n  var me = this;\n  this.calculateParams(otp, function (err, params) {\n    if (err) return callback(err);\n\n    me.verifyWithYubico(params, callback);\n  });\n};\n\n// If we have no network connectivity, we still may wish to extract the\n// identity from the OTP, but handy for offline applications.\nYub.prototype.verifyOffline = function (otp, callback) {\n\n  var identity = calculateIdentity(otp);\n  var encrypted = calculateEncrypted(otp);\n\n  var body = {\n    t: null,\n    otp: otp,\n    nonce: null,\n    sl: '0',\n    status: null,\n    signatureVerified: false,\n    nonceVerified: false,\n    identity: identity,\n    encrypted: encrypted,\n    encryptedHex: modhex.decode(encrypted),\n    serial: modhex.decodeInt(identity),\n    valid: false\n  };\n\n  callback(null,  body);\n};\n\n// Export Yub. To maintain backcompat, we attach a few static properties.\nmodule.exports = Yub;\n\nvar legacyInstance = null;\n// Don't break old methods!\nYub.init = function(clientID, secretKey) {\n  // As not to break backcompat, don't use retries with old API\n  legacyInstance = new Yub(clientID, secretKey, {maxTries: 0});\n};\nYub.verify = function(otp, callback) {\n  if (!legacyInstance) throw new Error('init() before verifying!');\n  return legacyInstance.verify(otp, callback);\n};\nYub.verifyOffline = Yub.prototype.verifyOffline; // No actual legacy instance required\nYub._calculateHmac = calculateHmac; // for tests\nYub._calculateStringToHash = calculateStringToHash; // for tests\nYub._servers = servers; // for tests\n", "'use strict';\nmodule.exports = require('./lib/yub.js');\n"],
  "mappings": "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",
  "names": ["require_yub"]
}
